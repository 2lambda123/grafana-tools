// Code generated by "catchall /Users/vkononov/work/sdk/board.go /Users/vkononov/work/sdk/panel.go /Users/vkononov/work/sdk/custom-types.go /Users/vkononov/work/sdk/row.go /Users/vkononov/work/sdk/alertnotification.go"; DO NOT EDIT.

package sdk

import "encoding/json"
import "fmt"

// MarshalJSON implements json.Marshaler.
func (r *Current) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["selected"] = r.Selected
	out["tags"] = r.Tags
	out["text"] = r.Text
	out["value"] = r.Value
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Current) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["selected"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for selected: expected bool, got %T", v)
		}
		r.Selected = vt
		delete(r.catchall, "Selected")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected string, got %T", v)
		}
		r.Text = vt
		delete(r.catchall, "Text")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(interface{})
		if !ok {
			return fmt.Errorf("wrong type for value: expected interface{}, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *TablePanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["columns"] = r.Columns
	out["sort"] = r.Sort
	out["styles"] = r.Styles
	out["transform"] = r.Transform
	out["targets"] = r.Targets
	out["scroll"] = r.Scroll
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *TablePanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["columns"]; ok {
		vt, ok := v.([]Column)
		if !ok {
			return fmt.Errorf("wrong type for columns: expected []Column, got %T", v)
		}
		r.Columns = vt
		delete(r.catchall, "Columns")
	}
	if v, ok := r.catchall["sort"]; ok {
		vt, ok := v.(*Sort)
		if !ok {
			return fmt.Errorf("wrong type for sort: expected *Sort, got %T", v)
		}
		r.Sort = vt
		delete(r.catchall, "Sort")
	}
	if v, ok := r.catchall["styles"]; ok {
		vt, ok := v.([]ColumnStyle)
		if !ok {
			return fmt.Errorf("wrong type for styles: expected []ColumnStyle, got %T", v)
		}
		r.Styles = vt
		delete(r.catchall, "Styles")
	}
	if v, ok := r.catchall["transform"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for transform: expected string, got %T", v)
		}
		r.Transform = vt
		delete(r.catchall, "Transform")
	}
	if v, ok := r.catchall["targets"]; ok {
		vt, ok := v.([]Target)
		if !ok {
			return fmt.Errorf("wrong type for targets: expected []Target, got %T", v)
		}
		r.Targets = vt
		delete(r.catchall, "Targets")
	}
	if v, ok := r.catchall["scroll"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for scroll: expected bool, got %T", v)
		}
		r.Scroll = vt
		delete(r.catchall, "Scroll")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Gauge) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["maxValue"] = r.MaxValue
	out["minValue"] = r.MinValue
	out["show"] = r.Show
	out["thresholdLabels"] = r.ThresholdLabels
	out["thresholdMarkers"] = r.ThresholdMarkers
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Gauge) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["maxValue"]; ok {
		vt, ok := v.(float32)
		if !ok {
			return fmt.Errorf("wrong type for maxValue: expected float32, got %T", v)
		}
		r.MaxValue = vt
		delete(r.catchall, "MaxValue")
	}
	if v, ok := r.catchall["minValue"]; ok {
		vt, ok := v.(float32)
		if !ok {
			return fmt.Errorf("wrong type for minValue: expected float32, got %T", v)
		}
		r.MinValue = vt
		delete(r.catchall, "MinValue")
	}
	if v, ok := r.catchall["show"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for show: expected bool, got %T", v)
		}
		r.Show = vt
		delete(r.catchall, "Show")
	}
	if v, ok := r.catchall["thresholdLabels"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for thresholdLabels: expected bool, got %T", v)
		}
		r.ThresholdLabels = vt
		delete(r.catchall, "ThresholdLabels")
	}
	if v, ok := r.catchall["thresholdMarkers"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for thresholdMarkers: expected bool, got %T", v)
		}
		r.ThresholdMarkers = vt
		delete(r.catchall, "ThresholdMarkers")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Annotation) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["builtIn"] = r.BuiltIn
	out["datasource"] = r.Datasource
	out["enable"] = r.Enable
	out["hide"] = r.Hide
	out["iconColor"] = r.IconColor
	out["iconSize"] = r.IconSize
	out["limit"] = r.Limit
	out["lineColor"] = r.LineColor
	out["name"] = r.Name
	out["query"] = r.Query
	out["rawQuery"] = r.RawQuery
	out["showIn"] = r.ShowIn
	out["showLine"] = r.ShowLine
	out["tags"] = r.Tags
	out["tagsField"] = r.TagsField
	out["textField"] = r.TextField
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Annotation) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["builtIn"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for builtIn: expected int, got %T", v)
		}
		r.BuiltIn = vt
		delete(r.catchall, "BuiltIn")
	}
	if v, ok := r.catchall["datasource"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for datasource: expected *string, got %T", v)
		}
		r.Datasource = vt
		delete(r.catchall, "Datasource")
	}
	if v, ok := r.catchall["enable"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for enable: expected bool, got %T", v)
		}
		r.Enable = vt
		delete(r.catchall, "Enable")
	}
	if v, ok := r.catchall["hide"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for hide: expected bool, got %T", v)
		}
		r.Hide = vt
		delete(r.catchall, "Hide")
	}
	if v, ok := r.catchall["iconColor"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for iconColor: expected string, got %T", v)
		}
		r.IconColor = vt
		delete(r.catchall, "IconColor")
	}
	if v, ok := r.catchall["iconSize"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for iconSize: expected uint, got %T", v)
		}
		r.IconSize = vt
		delete(r.catchall, "IconSize")
	}
	if v, ok := r.catchall["limit"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for limit: expected int, got %T", v)
		}
		r.Limit = vt
		delete(r.catchall, "Limit")
	}
	if v, ok := r.catchall["lineColor"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for lineColor: expected string, got %T", v)
		}
		r.LineColor = vt
		delete(r.catchall, "LineColor")
	}
	if v, ok := r.catchall["name"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for name: expected string, got %T", v)
		}
		r.Name = vt
		delete(r.catchall, "Name")
	}
	if v, ok := r.catchall["query"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for query: expected string, got %T", v)
		}
		r.Query = vt
		delete(r.catchall, "Query")
	}
	if v, ok := r.catchall["rawQuery"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for rawQuery: expected string, got %T", v)
		}
		r.RawQuery = vt
		delete(r.catchall, "RawQuery")
	}
	if v, ok := r.catchall["showIn"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for showIn: expected int, got %T", v)
		}
		r.ShowIn = vt
		delete(r.catchall, "ShowIn")
	}
	if v, ok := r.catchall["showLine"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for showLine: expected bool, got %T", v)
		}
		r.ShowLine = vt
		delete(r.catchall, "ShowLine")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	if v, ok := r.catchall["tagsField"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for tagsField: expected string, got %T", v)
		}
		r.TagsField = vt
		delete(r.catchall, "TagsField")
	}
	if v, ok := r.catchall["textField"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for textField: expected string, got %T", v)
		}
		r.TextField = vt
		delete(r.catchall, "TextField")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Column) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["text"] = r.TextType
	out["value"] = r.Value
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Column) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected string, got %T", v)
		}
		r.TextType = vt
		delete(r.catchall, "TextType")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for value: expected string, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *ValueMap) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["op"] = r.Op
	out["text"] = r.TextType
	out["value"] = r.Value
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *ValueMap) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["op"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for op: expected string, got %T", v)
		}
		r.Op = vt
		delete(r.catchall, "Op")
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected string, got %T", v)
		}
		r.TextType = vt
		delete(r.catchall, "TextType")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for value: expected string, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertEvaluator) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["params"] = r.Params
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertEvaluator) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["params"]; ok {
		vt, ok := v.([]float64)
		if !ok {
			return fmt.Errorf("wrong type for params: expected []float64, got %T", v)
		}
		r.Params = vt
		delete(r.catchall, "Params")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *SeriesOverride) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["alias"] = r.Alias
	out["bars"] = r.Bars
	out["color"] = r.Color
	out["dashes"] = r.Dashes
	out["fill"] = r.Fill
	out["fillBelowTo"] = r.FillBelowTo
	out["legend"] = r.Legend
	out["lines"] = r.Lines
	out["linewidth"] = r.Linewidth
	out["stack"] = r.Stack
	out["transform"] = r.Transform
	out["yaxis"] = r.YAxis
	out["zindex"] = r.ZIndex
	out["nullPointMode"] = r.NullPointMode
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *SeriesOverride) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["alias"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for alias: expected string, got %T", v)
		}
		r.Alias = vt
		delete(r.catchall, "Alias")
	}
	if v, ok := r.catchall["bars"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for bars: expected *bool, got %T", v)
		}
		r.Bars = vt
		delete(r.catchall, "Bars")
	}
	if v, ok := r.catchall["color"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for color: expected *string, got %T", v)
		}
		r.Color = vt
		delete(r.catchall, "Color")
	}
	if v, ok := r.catchall["dashes"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for dashes: expected bool, got %T", v)
		}
		r.Dashes = vt
		delete(r.catchall, "Dashes")
	}
	if v, ok := r.catchall["fill"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for fill: expected *int, got %T", v)
		}
		r.Fill = vt
		delete(r.catchall, "Fill")
	}
	if v, ok := r.catchall["fillBelowTo"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for fillBelowTo: expected *string, got %T", v)
		}
		r.FillBelowTo = vt
		delete(r.catchall, "FillBelowTo")
	}
	if v, ok := r.catchall["legend"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for legend: expected *bool, got %T", v)
		}
		r.Legend = vt
		delete(r.catchall, "Legend")
	}
	if v, ok := r.catchall["lines"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for lines: expected *bool, got %T", v)
		}
		r.Lines = vt
		delete(r.catchall, "Lines")
	}
	if v, ok := r.catchall["linewidth"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for linewidth: expected *int, got %T", v)
		}
		r.Linewidth = vt
		delete(r.catchall, "Linewidth")
	}
	if v, ok := r.catchall["stack"]; ok {
		vt, ok := v.(*BoolString)
		if !ok {
			return fmt.Errorf("wrong type for stack: expected *BoolString, got %T", v)
		}
		r.Stack = vt
		delete(r.catchall, "Stack")
	}
	if v, ok := r.catchall["transform"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for transform: expected *string, got %T", v)
		}
		r.Transform = vt
		delete(r.catchall, "Transform")
	}
	if v, ok := r.catchall["yaxis"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for yaxis: expected *int, got %T", v)
		}
		r.YAxis = vt
		delete(r.catchall, "YAxis")
	}
	if v, ok := r.catchall["zindex"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for zindex: expected *int, got %T", v)
		}
		r.ZIndex = vt
		delete(r.catchall, "ZIndex")
	}
	if v, ok := r.catchall["nullPointMode"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for nullPointMode: expected *string, got %T", v)
		}
		r.NullPointMode = vt
		delete(r.catchall, "NullPointMode")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *DashlistPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["mode"] = r.Mode
	out["limit"] = r.Limit
	out["query"] = r.Query
	out["tags"] = r.Tags
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *DashlistPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["mode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for mode: expected string, got %T", v)
		}
		r.Mode = vt
		delete(r.catchall, "Mode")
	}
	if v, ok := r.catchall["limit"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for limit: expected uint, got %T", v)
		}
		r.Limit = vt
		delete(r.catchall, "Limit")
	}
	if v, ok := r.catchall["query"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for query: expected string, got %T", v)
		}
		r.Query = vt
		delete(r.catchall, "Query")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Time) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["from"] = r.From
	out["to"] = r.To
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Time) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["from"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for from: expected string, got %T", v)
		}
		r.From = vt
		delete(r.catchall, "From")
	}
	if v, ok := r.catchall["to"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for to: expected string, got %T", v)
		}
		r.To = vt
		delete(r.catchall, "To")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Legend) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["alignAsTable"] = r.AlignAsTable
	out["avg"] = r.Avg
	out["current"] = r.Current
	out["hideEmpty"] = r.HideEmpty
	out["hideZero"] = r.HideZero
	out["max"] = r.Max
	out["min"] = r.Min
	out["rightSide"] = r.RightSide
	out["show"] = r.Show
	out["sideWidth"] = r.SideWidth
	out["sort"] = r.Sort
	out["sortDesc"] = r.SortDesc
	out["total"] = r.Total
	out["values"] = r.Values
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Legend) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["alignAsTable"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for alignAsTable: expected bool, got %T", v)
		}
		r.AlignAsTable = vt
		delete(r.catchall, "AlignAsTable")
	}
	if v, ok := r.catchall["avg"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for avg: expected bool, got %T", v)
		}
		r.Avg = vt
		delete(r.catchall, "Avg")
	}
	if v, ok := r.catchall["current"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for current: expected bool, got %T", v)
		}
		r.Current = vt
		delete(r.catchall, "Current")
	}
	if v, ok := r.catchall["hideEmpty"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for hideEmpty: expected bool, got %T", v)
		}
		r.HideEmpty = vt
		delete(r.catchall, "HideEmpty")
	}
	if v, ok := r.catchall["hideZero"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for hideZero: expected bool, got %T", v)
		}
		r.HideZero = vt
		delete(r.catchall, "HideZero")
	}
	if v, ok := r.catchall["max"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for max: expected bool, got %T", v)
		}
		r.Max = vt
		delete(r.catchall, "Max")
	}
	if v, ok := r.catchall["min"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for min: expected bool, got %T", v)
		}
		r.Min = vt
		delete(r.catchall, "Min")
	}
	if v, ok := r.catchall["rightSide"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for rightSide: expected bool, got %T", v)
		}
		r.RightSide = vt
		delete(r.catchall, "RightSide")
	}
	if v, ok := r.catchall["show"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for show: expected bool, got %T", v)
		}
		r.Show = vt
		delete(r.catchall, "Show")
	}
	if v, ok := r.catchall["sideWidth"]; ok {
		vt, ok := v.(*uint)
		if !ok {
			return fmt.Errorf("wrong type for sideWidth: expected *uint, got %T", v)
		}
		r.SideWidth = vt
		delete(r.catchall, "SideWidth")
	}
	if v, ok := r.catchall["sort"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for sort: expected string, got %T", v)
		}
		r.Sort = vt
		delete(r.catchall, "Sort")
	}
	if v, ok := r.catchall["sortDesc"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for sortDesc: expected bool, got %T", v)
		}
		r.SortDesc = vt
		delete(r.catchall, "SortDesc")
	}
	if v, ok := r.catchall["total"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for total: expected bool, got %T", v)
		}
		r.Total = vt
		delete(r.catchall, "Total")
	}
	if v, ok := r.catchall["values"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for values: expected bool, got %T", v)
		}
		r.Values = vt
		delete(r.catchall, "Values")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *RangeMap) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["from"] = r.From
	out["text"] = r.Text
	out["to"] = r.To
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *RangeMap) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["from"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for from: expected *string, got %T", v)
		}
		r.From = vt
		delete(r.catchall, "From")
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected *string, got %T", v)
		}
		r.Text = vt
		delete(r.catchall, "Text")
	}
	if v, ok := r.catchall["to"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for to: expected *string, got %T", v)
		}
		r.To = vt
		delete(r.catchall, "To")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *GraphPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["aliasColors"] = r.AliasColors
	out["bars"] = r.Bars
	out["dashLength"] = r.DashLength
	out["dashes"] = r.Dashes
	out["decimals"] = r.Decimals
	out["fill"] = r.Fill
	out["legend"] = r.Legend
	out["leftYAxisLabel"] = r.LeftYAxisLabel
	out["lines"] = r.Lines
	out["linewidth"] = r.Linewidth
	out["nullPointMode"] = r.NullPointMode
	out["percentage"] = r.Percentage
	out["pointradius"] = r.Pointradius
	out["points"] = r.Points
	out["rightYAxisLabel"] = r.RightYAxisLabel
	out["seriesOverrides"] = r.SeriesOverrides
	out["spaceLength"] = r.SpaceLength
	out["stack"] = r.Stack
	out["steppedLine"] = r.SteppedLine
	out["targets"] = r.Targets
	out["thresholds"] = r.Thresholds
	out["timeFrom"] = r.TimeFrom
	out["timeShift"] = r.TimeShift
	out["tooltip"] = r.Tooltip
	out["x-axis"] = r.XAxis
	out["y-axis"] = r.YAxis
	out["y_formats"] = r.YFormats
	out["xaxis"] = r.Xaxis
	out["yaxes"] = r.Yaxes
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *GraphPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["aliasColors"]; ok {
		vt, ok := v.(interface{})
		if !ok {
			return fmt.Errorf("wrong type for aliasColors: expected interface{}, got %T", v)
		}
		r.AliasColors = vt
		delete(r.catchall, "AliasColors")
	}
	if v, ok := r.catchall["bars"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for bars: expected bool, got %T", v)
		}
		r.Bars = vt
		delete(r.catchall, "Bars")
	}
	if v, ok := r.catchall["dashLength"]; ok {
		vt, ok := v.(*uint)
		if !ok {
			return fmt.Errorf("wrong type for dashLength: expected *uint, got %T", v)
		}
		r.DashLength = vt
		delete(r.catchall, "DashLength")
	}
	if v, ok := r.catchall["dashes"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for dashes: expected *bool, got %T", v)
		}
		r.Dashes = vt
		delete(r.catchall, "Dashes")
	}
	if v, ok := r.catchall["decimals"]; ok {
		vt, ok := v.(*uint)
		if !ok {
			return fmt.Errorf("wrong type for decimals: expected *uint, got %T", v)
		}
		r.Decimals = vt
		delete(r.catchall, "Decimals")
	}
	if v, ok := r.catchall["fill"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for fill: expected int, got %T", v)
		}
		r.Fill = vt
		delete(r.catchall, "Fill")
	}
	if v, ok := r.catchall["legend"]; ok {
		vt, ok := v.(Legend)
		if !ok {
			return fmt.Errorf("wrong type for legend: expected Legend, got %T", v)
		}
		r.Legend = vt
		delete(r.catchall, "Legend")
	}
	if v, ok := r.catchall["leftYAxisLabel"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for leftYAxisLabel: expected *string, got %T", v)
		}
		r.LeftYAxisLabel = vt
		delete(r.catchall, "LeftYAxisLabel")
	}
	if v, ok := r.catchall["lines"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for lines: expected bool, got %T", v)
		}
		r.Lines = vt
		delete(r.catchall, "Lines")
	}
	if v, ok := r.catchall["linewidth"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for linewidth: expected uint, got %T", v)
		}
		r.Linewidth = vt
		delete(r.catchall, "Linewidth")
	}
	if v, ok := r.catchall["nullPointMode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for nullPointMode: expected string, got %T", v)
		}
		r.NullPointMode = vt
		delete(r.catchall, "NullPointMode")
	}
	if v, ok := r.catchall["percentage"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for percentage: expected bool, got %T", v)
		}
		r.Percentage = vt
		delete(r.catchall, "Percentage")
	}
	if v, ok := r.catchall["pointradius"]; ok {
		vt, ok := v.(float32)
		if !ok {
			return fmt.Errorf("wrong type for pointradius: expected float32, got %T", v)
		}
		r.Pointradius = vt
		delete(r.catchall, "Pointradius")
	}
	if v, ok := r.catchall["points"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for points: expected bool, got %T", v)
		}
		r.Points = vt
		delete(r.catchall, "Points")
	}
	if v, ok := r.catchall["rightYAxisLabel"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for rightYAxisLabel: expected *string, got %T", v)
		}
		r.RightYAxisLabel = vt
		delete(r.catchall, "RightYAxisLabel")
	}
	if v, ok := r.catchall["seriesOverrides"]; ok {
		vt, ok := v.([]SeriesOverride)
		if !ok {
			return fmt.Errorf("wrong type for seriesOverrides: expected []SeriesOverride, got %T", v)
		}
		r.SeriesOverrides = vt
		delete(r.catchall, "SeriesOverrides")
	}
	if v, ok := r.catchall["spaceLength"]; ok {
		vt, ok := v.(*uint)
		if !ok {
			return fmt.Errorf("wrong type for spaceLength: expected *uint, got %T", v)
		}
		r.SpaceLength = vt
		delete(r.catchall, "SpaceLength")
	}
	if v, ok := r.catchall["stack"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for stack: expected bool, got %T", v)
		}
		r.Stack = vt
		delete(r.catchall, "Stack")
	}
	if v, ok := r.catchall["steppedLine"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for steppedLine: expected bool, got %T", v)
		}
		r.SteppedLine = vt
		delete(r.catchall, "SteppedLine")
	}
	if v, ok := r.catchall["targets"]; ok {
		vt, ok := v.([]Target)
		if !ok {
			return fmt.Errorf("wrong type for targets: expected []Target, got %T", v)
		}
		r.Targets = vt
		delete(r.catchall, "Targets")
	}
	if v, ok := r.catchall["thresholds"]; ok {
		vt, ok := v.([]Threshold)
		if !ok {
			return fmt.Errorf("wrong type for thresholds: expected []Threshold, got %T", v)
		}
		r.Thresholds = vt
		delete(r.catchall, "Thresholds")
	}
	if v, ok := r.catchall["timeFrom"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for timeFrom: expected *string, got %T", v)
		}
		r.TimeFrom = vt
		delete(r.catchall, "TimeFrom")
	}
	if v, ok := r.catchall["timeShift"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for timeShift: expected *string, got %T", v)
		}
		r.TimeShift = vt
		delete(r.catchall, "TimeShift")
	}
	if v, ok := r.catchall["tooltip"]; ok {
		vt, ok := v.(Tooltip)
		if !ok {
			return fmt.Errorf("wrong type for tooltip: expected Tooltip, got %T", v)
		}
		r.Tooltip = vt
		delete(r.catchall, "Tooltip")
	}
	if v, ok := r.catchall["x-axis"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for x-axis: expected bool, got %T", v)
		}
		r.XAxis = vt
		delete(r.catchall, "XAxis")
	}
	if v, ok := r.catchall["y-axis"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for y-axis: expected bool, got %T", v)
		}
		r.YAxis = vt
		delete(r.catchall, "YAxis")
	}
	if v, ok := r.catchall["y_formats"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for y_formats: expected []string, got %T", v)
		}
		r.YFormats = vt
		delete(r.catchall, "YFormats")
	}
	if v, ok := r.catchall["xaxis"]; ok {
		vt, ok := v.(Axis)
		if !ok {
			return fmt.Errorf("wrong type for xaxis: expected Axis, got %T", v)
		}
		r.Xaxis = vt
		delete(r.catchall, "Xaxis")
	}
	if v, ok := r.catchall["yaxes"]; ok {
		vt, ok := v.([]Axis)
		if !ok {
			return fmt.Errorf("wrong type for yaxes: expected []Axis, got %T", v)
		}
		r.Yaxes = vt
		delete(r.catchall, "Yaxes")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertlistPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["onlyAlertsOnDashboard"] = r.OnlyAlertsOnDashboard
	out["show"] = r.Show
	out["sortOrder"] = r.SortOrder
	out["limit"] = r.Limit
	out["stateFilter"] = r.StateFilter
	out["nameFilter"] = r.NameFilter
	out["dashboardTags"] = r.DashboardTags
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertlistPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["onlyAlertsOnDashboard"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for onlyAlertsOnDashboard: expected bool, got %T", v)
		}
		r.OnlyAlertsOnDashboard = vt
		delete(r.catchall, "OnlyAlertsOnDashboard")
	}
	if v, ok := r.catchall["show"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for show: expected string, got %T", v)
		}
		r.Show = vt
		delete(r.catchall, "Show")
	}
	if v, ok := r.catchall["sortOrder"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for sortOrder: expected int, got %T", v)
		}
		r.SortOrder = vt
		delete(r.catchall, "SortOrder")
	}
	if v, ok := r.catchall["limit"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for limit: expected int, got %T", v)
		}
		r.Limit = vt
		delete(r.catchall, "Limit")
	}
	if v, ok := r.catchall["stateFilter"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for stateFilter: expected []string, got %T", v)
		}
		r.StateFilter = vt
		delete(r.catchall, "StateFilter")
	}
	if v, ok := r.catchall["nameFilter"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for nameFilter: expected string, got %T", v)
		}
		r.NameFilter = vt
		delete(r.catchall, "NameFilter")
	}
	if v, ok := r.catchall["dashboardTags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for dashboardTags: expected []string, got %T", v)
		}
		r.DashboardTags = vt
		delete(r.catchall, "DashboardTags")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Axis) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["decimals"] = r.Decimals
	out["format"] = r.Format
	out["logBase"] = r.LogBase
	out["max"] = r.Max
	out["min"] = r.Min
	out["mode"] = r.Mode
	out["show"] = r.Show
	out["label"] = r.Label
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Axis) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["decimals"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for decimals: expected int, got %T", v)
		}
		r.Decimals = vt
		delete(r.catchall, "Decimals")
	}
	if v, ok := r.catchall["format"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for format: expected string, got %T", v)
		}
		r.Format = vt
		delete(r.catchall, "Format")
	}
	if v, ok := r.catchall["logBase"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for logBase: expected int, got %T", v)
		}
		r.LogBase = vt
		delete(r.catchall, "LogBase")
	}
	if v, ok := r.catchall["max"]; ok {
		vt, ok := v.(*FloatOrString)
		if !ok {
			return fmt.Errorf("wrong type for max: expected *FloatOrString, got %T", v)
		}
		r.Max = vt
		delete(r.catchall, "Max")
	}
	if v, ok := r.catchall["min"]; ok {
		vt, ok := v.(*FloatOrString)
		if !ok {
			return fmt.Errorf("wrong type for min: expected *FloatOrString, got %T", v)
		}
		r.Min = vt
		delete(r.catchall, "Min")
	}
	if v, ok := r.catchall["mode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for mode: expected string, got %T", v)
		}
		r.Mode = vt
		delete(r.catchall, "Mode")
	}
	if v, ok := r.catchall["show"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for show: expected bool, got %T", v)
		}
		r.Show = vt
		delete(r.catchall, "Show")
	}
	if v, ok := r.catchall["label"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for label: expected string, got %T", v)
		}
		r.Label = vt
		delete(r.catchall, "Label")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertQuery) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["params"] = r.Params
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertQuery) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["params"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for params: expected []string, got %T", v)
		}
		r.Params = vt
		delete(r.catchall, "Params")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Target) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["refId"] = r.RefID
	out["datasource"] = r.Datasource
	out["hide"] = r.Hide
	out["expr"] = r.Expr
	out["intervalFactor"] = r.IntervalFactor
	out["interval"] = r.Interval
	out["step"] = r.Step
	out["legendFormat"] = r.LegendFormat
	out["instant"] = r.Instant
	out["format"] = r.Format
	out["dsType"] = r.DsType
	out["metrics"] = r.Metrics
	out["query"] = r.Query
	out["alias"] = r.Alias
	out["rawQuery"] = r.RawQuery
	out["timeField"] = r.TimeField
	out["bucketAggs"] = r.BucketAggs
	out["target"] = r.Target
	out["namespace"] = r.Namespace
	out["metricName"] = r.MetricName
	out["statistics"] = r.Statistics
	out["dimensions"] = r.Dimensions
	out["period"] = r.Period
	out["region"] = r.Region
	out["alignOptions"] = r.AlignOptions
	out["aliasBy"] = r.AliasBy
	out["metricType"] = r.MetricType
	out["metricKind"] = r.MetricKind
	out["filters"] = r.Filters
	out["alignmentPeriod"] = r.AlignmentPeriod
	out["crossSeriesReducer"] = r.CrossSeriesReducer
	out["perSeriesAligner"] = r.PerSeriesAligner
	out["valueType"] = r.ValueType
	out["groupBys"] = r.GroupBys
	out["data"] = r.Data
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Target) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["refId"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for refId: expected string, got %T", v)
		}
		r.RefID = vt
		delete(r.catchall, "RefID")
	}
	if v, ok := r.catchall["datasource"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for datasource: expected string, got %T", v)
		}
		r.Datasource = vt
		delete(r.catchall, "Datasource")
	}
	if v, ok := r.catchall["hide"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for hide: expected *bool, got %T", v)
		}
		r.Hide = vt
		delete(r.catchall, "Hide")
	}
	if v, ok := r.catchall["expr"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for expr: expected string, got %T", v)
		}
		r.Expr = vt
		delete(r.catchall, "Expr")
	}
	if v, ok := r.catchall["intervalFactor"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for intervalFactor: expected int, got %T", v)
		}
		r.IntervalFactor = vt
		delete(r.catchall, "IntervalFactor")
	}
	if v, ok := r.catchall["interval"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for interval: expected string, got %T", v)
		}
		r.Interval = vt
		delete(r.catchall, "Interval")
	}
	if v, ok := r.catchall["step"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for step: expected int, got %T", v)
		}
		r.Step = vt
		delete(r.catchall, "Step")
	}
	if v, ok := r.catchall["legendFormat"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for legendFormat: expected string, got %T", v)
		}
		r.LegendFormat = vt
		delete(r.catchall, "LegendFormat")
	}
	if v, ok := r.catchall["instant"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for instant: expected bool, got %T", v)
		}
		r.Instant = vt
		delete(r.catchall, "Instant")
	}
	if v, ok := r.catchall["format"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for format: expected string, got %T", v)
		}
		r.Format = vt
		delete(r.catchall, "Format")
	}
	if v, ok := r.catchall["dsType"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for dsType: expected *string, got %T", v)
		}
		r.DsType = vt
		delete(r.catchall, "DsType")
	}
	if v, ok := r.catchall["metrics"]; ok {
		vt, ok := v.([]Metric)
		if !ok {
			return fmt.Errorf("wrong type for metrics: expected []Metric, got %T", v)
		}
		r.Metrics = vt
		delete(r.catchall, "Metrics")
	}
	if v, ok := r.catchall["query"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for query: expected string, got %T", v)
		}
		r.Query = vt
		delete(r.catchall, "Query")
	}
	if v, ok := r.catchall["alias"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for alias: expected string, got %T", v)
		}
		r.Alias = vt
		delete(r.catchall, "Alias")
	}
	if v, ok := r.catchall["rawQuery"]; ok {
		vt, ok := v.(*BoolString)
		if !ok {
			return fmt.Errorf("wrong type for rawQuery: expected *BoolString, got %T", v)
		}
		r.RawQuery = vt
		delete(r.catchall, "RawQuery")
	}
	if v, ok := r.catchall["timeField"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for timeField: expected string, got %T", v)
		}
		r.TimeField = vt
		delete(r.catchall, "TimeField")
	}
	if v, ok := r.catchall["bucketAggs"]; ok {
		vt, ok := v.([]BucketAgg)
		if !ok {
			return fmt.Errorf("wrong type for bucketAggs: expected []BucketAgg, got %T", v)
		}
		r.BucketAggs = vt
		delete(r.catchall, "BucketAggs")
	}
	if v, ok := r.catchall["target"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for target: expected string, got %T", v)
		}
		r.Target = vt
		delete(r.catchall, "Target")
	}
	if v, ok := r.catchall["namespace"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for namespace: expected string, got %T", v)
		}
		r.Namespace = vt
		delete(r.catchall, "Namespace")
	}
	if v, ok := r.catchall["metricName"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for metricName: expected string, got %T", v)
		}
		r.MetricName = vt
		delete(r.catchall, "MetricName")
	}
	if v, ok := r.catchall["statistics"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for statistics: expected []string, got %T", v)
		}
		r.Statistics = vt
		delete(r.catchall, "Statistics")
	}
	if v, ok := r.catchall["dimensions"]; ok {
		vt, ok := v.(map[string]string)
		if !ok {
			return fmt.Errorf("wrong type for dimensions: expected map[string]string, got %T", v)
		}
		r.Dimensions = vt
		delete(r.catchall, "Dimensions")
	}
	if v, ok := r.catchall["period"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for period: expected string, got %T", v)
		}
		r.Period = vt
		delete(r.catchall, "Period")
	}
	if v, ok := r.catchall["region"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for region: expected string, got %T", v)
		}
		r.Region = vt
		delete(r.catchall, "Region")
	}
	if v, ok := r.catchall["alignOptions"]; ok {
		vt, ok := v.([]StackdriverAlignOptions)
		if !ok {
			return fmt.Errorf("wrong type for alignOptions: expected []StackdriverAlignOptions, got %T", v)
		}
		r.AlignOptions = vt
		delete(r.catchall, "AlignOptions")
	}
	if v, ok := r.catchall["aliasBy"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for aliasBy: expected string, got %T", v)
		}
		r.AliasBy = vt
		delete(r.catchall, "AliasBy")
	}
	if v, ok := r.catchall["metricType"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for metricType: expected string, got %T", v)
		}
		r.MetricType = vt
		delete(r.catchall, "MetricType")
	}
	if v, ok := r.catchall["metricKind"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for metricKind: expected string, got %T", v)
		}
		r.MetricKind = vt
		delete(r.catchall, "MetricKind")
	}
	if v, ok := r.catchall["filters"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for filters: expected []string, got %T", v)
		}
		r.Filters = vt
		delete(r.catchall, "Filters")
	}
	if v, ok := r.catchall["alignmentPeriod"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for alignmentPeriod: expected string, got %T", v)
		}
		r.AlignmentPeriod = vt
		delete(r.catchall, "AlignmentPeriod")
	}
	if v, ok := r.catchall["crossSeriesReducer"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for crossSeriesReducer: expected string, got %T", v)
		}
		r.CrossSeriesReducer = vt
		delete(r.catchall, "CrossSeriesReducer")
	}
	if v, ok := r.catchall["perSeriesAligner"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for perSeriesAligner: expected string, got %T", v)
		}
		r.PerSeriesAligner = vt
		delete(r.catchall, "PerSeriesAligner")
	}
	if v, ok := r.catchall["valueType"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for valueType: expected string, got %T", v)
		}
		r.ValueType = vt
		delete(r.catchall, "ValueType")
	}
	if v, ok := r.catchall["groupBys"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for groupBys: expected []string, got %T", v)
		}
		r.GroupBys = vt
		delete(r.catchall, "GroupBys")
	}
	if v, ok := r.catchall["data"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for data: expected string, got %T", v)
		}
		r.Data = vt
		delete(r.catchall, "Data")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Option) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["text"] = r.Text
	out["value"] = r.Value
	out["selected"] = r.Selected
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Option) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected string, got %T", v)
		}
		r.Text = vt
		delete(r.catchall, "Text")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for value: expected string, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	if v, ok := r.catchall["selected"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for selected: expected bool, got %T", v)
		}
		r.Selected = vt
		delete(r.catchall, "Selected")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *StackdriverAlignOption) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["label"] = r.Label
	out["metricKinds"] = r.MetricKinds
	out["text"] = r.Text
	out["value"] = r.Value
	out["valueTypes"] = r.ValueTypes
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *StackdriverAlignOption) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["label"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for label: expected string, got %T", v)
		}
		r.Label = vt
		delete(r.catchall, "Label")
	}
	if v, ok := r.catchall["metricKinds"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for metricKinds: expected []string, got %T", v)
		}
		r.MetricKinds = vt
		delete(r.catchall, "MetricKinds")
	}
	if v, ok := r.catchall["text"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for text: expected string, got %T", v)
		}
		r.Text = vt
		delete(r.catchall, "Text")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for value: expected string, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	if v, ok := r.catchall["valueTypes"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for valueTypes: expected []string, got %T", v)
		}
		r.ValueTypes = vt
		delete(r.catchall, "ValueTypes")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *MapType) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["name"] = r.Name
	out["value"] = r.Value
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *MapType) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["name"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for name: expected *string, got %T", v)
		}
		r.Name = vt
		delete(r.catchall, "Name")
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for value: expected *int, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *SinglestatPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["colors"] = r.Colors
	out["colorValue"] = r.ColorValue
	out["colorBackground"] = r.ColorBackground
	out["colorPostfix"] = r.ColorPostfix
	out["colorPrefix"] = r.ColorPrefix
	out["decimals"] = r.Decimals
	out["format"] = r.Format
	out["gauge"] = r.Gauge
	out["mappingType"] = r.MappingType
	out["mappingTypes"] = r.MappingTypes
	out["maxDataPoints"] = r.MaxDataPoints
	out["nullPointMode"] = r.NullPointMode
	out["postfix"] = r.Postfix
	out["postfixFontSize"] = r.PostfixFontSize
	out["prefix"] = r.Prefix
	out["prefixFontSize"] = r.PrefixFontSize
	out["rangeMaps"] = r.RangeMaps
	out["sparkline"] = r.SparkLine
	out["targets"] = r.Targets
	out["thresholds"] = r.Thresholds
	out["valueFontSize"] = r.ValueFontSize
	out["valueMaps"] = r.ValueMaps
	out["valueName"] = r.ValueName
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *SinglestatPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["colors"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for colors: expected []string, got %T", v)
		}
		r.Colors = vt
		delete(r.catchall, "Colors")
	}
	if v, ok := r.catchall["colorValue"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for colorValue: expected bool, got %T", v)
		}
		r.ColorValue = vt
		delete(r.catchall, "ColorValue")
	}
	if v, ok := r.catchall["colorBackground"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for colorBackground: expected bool, got %T", v)
		}
		r.ColorBackground = vt
		delete(r.catchall, "ColorBackground")
	}
	if v, ok := r.catchall["colorPostfix"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for colorPostfix: expected bool, got %T", v)
		}
		r.ColorPostfix = vt
		delete(r.catchall, "ColorPostfix")
	}
	if v, ok := r.catchall["colorPrefix"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for colorPrefix: expected bool, got %T", v)
		}
		r.ColorPrefix = vt
		delete(r.catchall, "ColorPrefix")
	}
	if v, ok := r.catchall["decimals"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for decimals: expected int, got %T", v)
		}
		r.Decimals = vt
		delete(r.catchall, "Decimals")
	}
	if v, ok := r.catchall["format"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for format: expected string, got %T", v)
		}
		r.Format = vt
		delete(r.catchall, "Format")
	}
	if v, ok := r.catchall["gauge"]; ok {
		vt, ok := v.(Gauge)
		if !ok {
			return fmt.Errorf("wrong type for gauge: expected Gauge, got %T", v)
		}
		r.Gauge = vt
		delete(r.catchall, "Gauge")
	}
	if v, ok := r.catchall["mappingType"]; ok {
		vt, ok := v.(*uint)
		if !ok {
			return fmt.Errorf("wrong type for mappingType: expected *uint, got %T", v)
		}
		r.MappingType = vt
		delete(r.catchall, "MappingType")
	}
	if v, ok := r.catchall["mappingTypes"]; ok {
		vt, ok := v.([]*MapType)
		if !ok {
			return fmt.Errorf("wrong type for mappingTypes: expected []*MapType, got %T", v)
		}
		r.MappingTypes = vt
		delete(r.catchall, "MappingTypes")
	}
	if v, ok := r.catchall["maxDataPoints"]; ok {
		vt, ok := v.(*IntString)
		if !ok {
			return fmt.Errorf("wrong type for maxDataPoints: expected *IntString, got %T", v)
		}
		r.MaxDataPoints = vt
		delete(r.catchall, "MaxDataPoints")
	}
	if v, ok := r.catchall["nullPointMode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for nullPointMode: expected string, got %T", v)
		}
		r.NullPointMode = vt
		delete(r.catchall, "NullPointMode")
	}
	if v, ok := r.catchall["postfix"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for postfix: expected *string, got %T", v)
		}
		r.Postfix = vt
		delete(r.catchall, "Postfix")
	}
	if v, ok := r.catchall["postfixFontSize"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for postfixFontSize: expected *string, got %T", v)
		}
		r.PostfixFontSize = vt
		delete(r.catchall, "PostfixFontSize")
	}
	if v, ok := r.catchall["prefix"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for prefix: expected *string, got %T", v)
		}
		r.Prefix = vt
		delete(r.catchall, "Prefix")
	}
	if v, ok := r.catchall["prefixFontSize"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for prefixFontSize: expected *string, got %T", v)
		}
		r.PrefixFontSize = vt
		delete(r.catchall, "PrefixFontSize")
	}
	if v, ok := r.catchall["rangeMaps"]; ok {
		vt, ok := v.([]*RangeMap)
		if !ok {
			return fmt.Errorf("wrong type for rangeMaps: expected []*RangeMap, got %T", v)
		}
		r.RangeMaps = vt
		delete(r.catchall, "RangeMaps")
	}
	if v, ok := r.catchall["sparkline"]; ok {
		vt, ok := v.(SparkLine)
		if !ok {
			return fmt.Errorf("wrong type for sparkline: expected SparkLine, got %T", v)
		}
		r.SparkLine = vt
		delete(r.catchall, "SparkLine")
	}
	if v, ok := r.catchall["targets"]; ok {
		vt, ok := v.([]Target)
		if !ok {
			return fmt.Errorf("wrong type for targets: expected []Target, got %T", v)
		}
		r.Targets = vt
		delete(r.catchall, "Targets")
	}
	if v, ok := r.catchall["thresholds"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for thresholds: expected string, got %T", v)
		}
		r.Thresholds = vt
		delete(r.catchall, "Thresholds")
	}
	if v, ok := r.catchall["valueFontSize"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for valueFontSize: expected string, got %T", v)
		}
		r.ValueFontSize = vt
		delete(r.catchall, "ValueFontSize")
	}
	if v, ok := r.catchall["valueMaps"]; ok {
		vt, ok := v.([]ValueMap)
		if !ok {
			return fmt.Errorf("wrong type for valueMaps: expected []ValueMap, got %T", v)
		}
		r.ValueMaps = vt
		delete(r.catchall, "ValueMaps")
	}
	if v, ok := r.catchall["valueName"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for valueName: expected string, got %T", v)
		}
		r.ValueName = vt
		delete(r.catchall, "ValueName")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *BucketAgg) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["id"] = r.ID
	out["field"] = r.Field
	out["type"] = r.Type
	out["settings"] = r.Settings
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *BucketAgg) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["id"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for id: expected string, got %T", v)
		}
		r.ID = vt
		delete(r.catchall, "ID")
	}
	if v, ok := r.catchall["field"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for field: expected string, got %T", v)
		}
		r.Field = vt
		delete(r.catchall, "Field")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	if v, ok := r.catchall["settings"]; ok {
		vt, ok := v.(SettingsType)
		if !ok {
			return fmt.Errorf("wrong type for settings: expected SettingsType, got %T", v)
		}
		r.Settings = vt
		delete(r.catchall, "Settings")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Tooltip) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["shared"] = r.Shared
	out["value_type"] = r.ValueType
	out["msResolution"] = r.MsResolution
	out["sort"] = r.Sort
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Tooltip) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["shared"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for shared: expected bool, got %T", v)
		}
		r.Shared = vt
		delete(r.catchall, "Shared")
	}
	if v, ok := r.catchall["value_type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for value_type: expected string, got %T", v)
		}
		r.ValueType = vt
		delete(r.catchall, "ValueType")
	}
	if v, ok := r.catchall["msResolution"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for msResolution: expected bool, got %T", v)
		}
		r.MsResolution = vt
		delete(r.catchall, "MsResolution")
	}
	if v, ok := r.catchall["sort"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for sort: expected int, got %T", v)
		}
		r.Sort = vt
		delete(r.catchall, "Sort")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Templating) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["list"] = r.List
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Templating) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["list"]; ok {
		vt, ok := v.([]*TemplateVar)
		if !ok {
			return fmt.Errorf("wrong type for list: expected []*TemplateVar, got %T", v)
		}
		r.List = vt
		delete(r.catchall, "List")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Alert) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["conditions"] = r.Conditions
	out["executionErrorState"] = r.ExecutionErrorState
	out["frequency"] = r.Frequency
	out["handler"] = r.Handler
	out["name"] = r.Name
	out["noDataState"] = r.NoDataState
	out["notifications"] = r.Notifications
	out["message"] = r.Message
	out["for"] = r.For
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Alert) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["conditions"]; ok {
		vt, ok := v.([]AlertCondition)
		if !ok {
			return fmt.Errorf("wrong type for conditions: expected []AlertCondition, got %T", v)
		}
		r.Conditions = vt
		delete(r.catchall, "Conditions")
	}
	if v, ok := r.catchall["executionErrorState"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for executionErrorState: expected string, got %T", v)
		}
		r.ExecutionErrorState = vt
		delete(r.catchall, "ExecutionErrorState")
	}
	if v, ok := r.catchall["frequency"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for frequency: expected string, got %T", v)
		}
		r.Frequency = vt
		delete(r.catchall, "Frequency")
	}
	if v, ok := r.catchall["handler"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for handler: expected int, got %T", v)
		}
		r.Handler = vt
		delete(r.catchall, "Handler")
	}
	if v, ok := r.catchall["name"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for name: expected string, got %T", v)
		}
		r.Name = vt
		delete(r.catchall, "Name")
	}
	if v, ok := r.catchall["noDataState"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for noDataState: expected string, got %T", v)
		}
		r.NoDataState = vt
		delete(r.catchall, "NoDataState")
	}
	if v, ok := r.catchall["notifications"]; ok {
		vt, ok := v.([]AlertNotification)
		if !ok {
			return fmt.Errorf("wrong type for notifications: expected []AlertNotification, got %T", v)
		}
		r.Notifications = vt
		delete(r.catchall, "Notifications")
	}
	if v, ok := r.catchall["message"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for message: expected string, got %T", v)
		}
		r.Message = vt
		delete(r.catchall, "Message")
	}
	if v, ok := r.catchall["for"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for for: expected string, got %T", v)
		}
		r.For = vt
		delete(r.catchall, "For")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Row) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["title"] = r.Title
	out["showTitle"] = r.ShowTitle
	out["collapse"] = r.Collapse
	out["editable"] = r.Editable
	out["height"] = r.Height
	out["panels"] = r.Panels
	out["repeat"] = r.Repeat
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Row) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["title"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for title: expected string, got %T", v)
		}
		r.Title = vt
		delete(r.catchall, "Title")
	}
	if v, ok := r.catchall["showTitle"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for showTitle: expected bool, got %T", v)
		}
		r.ShowTitle = vt
		delete(r.catchall, "ShowTitle")
	}
	if v, ok := r.catchall["collapse"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for collapse: expected bool, got %T", v)
		}
		r.Collapse = vt
		delete(r.catchall, "Collapse")
	}
	if v, ok := r.catchall["editable"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for editable: expected bool, got %T", v)
		}
		r.Editable = vt
		delete(r.catchall, "Editable")
	}
	if v, ok := r.catchall["height"]; ok {
		vt, ok := v.(FloatOrString)
		if !ok {
			return fmt.Errorf("wrong type for height: expected FloatOrString, got %T", v)
		}
		r.Height = vt
		delete(r.catchall, "Height")
	}
	if v, ok := r.catchall["panels"]; ok {
		vt, ok := v.([]Panel)
		if !ok {
			return fmt.Errorf("wrong type for panels: expected []Panel, got %T", v)
		}
		r.Panels = vt
		delete(r.catchall, "Panels")
	}
	if v, ok := r.catchall["repeat"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for repeat: expected *string, got %T", v)
		}
		r.Repeat = vt
		delete(r.catchall, "Repeat")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertReducer) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["params"] = r.Params
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertReducer) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["params"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for params: expected []string, got %T", v)
		}
		r.Params = vt
		delete(r.catchall, "Params")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Threshold) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["value"] = r.Value
	out["colorMode"] = r.ColorMode
	out["op"] = r.Op
	out["fill"] = r.Fill
	out["line"] = r.Line
	out["fillColor"] = r.FillColor
	out["lineColor"] = r.LineColor
	out["yaxis"] = r.Yaxis
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Threshold) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["value"]; ok {
		vt, ok := v.(float32)
		if !ok {
			return fmt.Errorf("wrong type for value: expected float32, got %T", v)
		}
		r.Value = vt
		delete(r.catchall, "Value")
	}
	if v, ok := r.catchall["colorMode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for colorMode: expected string, got %T", v)
		}
		r.ColorMode = vt
		delete(r.catchall, "ColorMode")
	}
	if v, ok := r.catchall["op"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for op: expected string, got %T", v)
		}
		r.Op = vt
		delete(r.catchall, "Op")
	}
	if v, ok := r.catchall["fill"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for fill: expected bool, got %T", v)
		}
		r.Fill = vt
		delete(r.catchall, "Fill")
	}
	if v, ok := r.catchall["line"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for line: expected bool, got %T", v)
		}
		r.Line = vt
		delete(r.catchall, "Line")
	}
	if v, ok := r.catchall["fillColor"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for fillColor: expected string, got %T", v)
		}
		r.FillColor = vt
		delete(r.catchall, "FillColor")
	}
	if v, ok := r.catchall["lineColor"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for lineColor: expected string, got %T", v)
		}
		r.LineColor = vt
		delete(r.catchall, "LineColor")
	}
	if v, ok := r.catchall["yaxis"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for yaxis: expected string, got %T", v)
		}
		r.Yaxis = vt
		delete(r.catchall, "Yaxis")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *TemplateVar) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["allFormat"] = r.AllFormat
	out["allValue"] = r.AllValue
	out["auto"] = r.Auto
	out["auto_count"] = r.AutoCount
	out["auto_min"] = r.AutoMin
	out["current"] = r.Current
	out["datasource"] = r.Datasource
	out["definition"] = r.Definition
	out["hide"] = r.Hide
	out["index"] = r.Index
	out["includeAll"] = r.IncludeAll
	out["label"] = r.Label
	out["multi"] = r.Multi
	out["multiFormat"] = r.MultiFormat
	out["name"] = r.Name
	out["options"] = r.Options
	out["query"] = r.Query
	out["refresh"] = r.Refresh
	out["regex"] = r.Regex
	out["skipUrlSync"] = r.SkipUrlSync
	out["sort"] = r.Sort
	out["tagValuesQuery"] = r.TagValuesQuery
	out["tags"] = r.Tags
	out["tagsQuery"] = r.TagsQuery
	out["type"] = r.Type
	out["useTags"] = r.UseTags
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *TemplateVar) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["allFormat"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for allFormat: expected string, got %T", v)
		}
		r.AllFormat = vt
		delete(r.catchall, "AllFormat")
	}
	if v, ok := r.catchall["allValue"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for allValue: expected string, got %T", v)
		}
		r.AllValue = vt
		delete(r.catchall, "AllValue")
	}
	if v, ok := r.catchall["auto"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for auto: expected bool, got %T", v)
		}
		r.Auto = vt
		delete(r.catchall, "Auto")
	}
	if v, ok := r.catchall["auto_count"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for auto_count: expected *int, got %T", v)
		}
		r.AutoCount = vt
		delete(r.catchall, "AutoCount")
	}
	if v, ok := r.catchall["auto_min"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for auto_min: expected string, got %T", v)
		}
		r.AutoMin = vt
		delete(r.catchall, "AutoMin")
	}
	if v, ok := r.catchall["current"]; ok {
		vt, ok := v.(Current)
		if !ok {
			return fmt.Errorf("wrong type for current: expected Current, got %T", v)
		}
		r.Current = vt
		delete(r.catchall, "Current")
	}
	if v, ok := r.catchall["datasource"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for datasource: expected *string, got %T", v)
		}
		r.Datasource = vt
		delete(r.catchall, "Datasource")
	}
	if v, ok := r.catchall["definition"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for definition: expected string, got %T", v)
		}
		r.Definition = vt
		delete(r.catchall, "Definition")
	}
	if v, ok := r.catchall["hide"]; ok {
		vt, ok := v.(uint8)
		if !ok {
			return fmt.Errorf("wrong type for hide: expected uint8, got %T", v)
		}
		r.Hide = vt
		delete(r.catchall, "Hide")
	}
	if v, ok := r.catchall["index"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for index: expected int, got %T", v)
		}
		r.Index = vt
		delete(r.catchall, "Index")
	}
	if v, ok := r.catchall["includeAll"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for includeAll: expected bool, got %T", v)
		}
		r.IncludeAll = vt
		delete(r.catchall, "IncludeAll")
	}
	if v, ok := r.catchall["label"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for label: expected string, got %T", v)
		}
		r.Label = vt
		delete(r.catchall, "Label")
	}
	if v, ok := r.catchall["multi"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for multi: expected bool, got %T", v)
		}
		r.Multi = vt
		delete(r.catchall, "Multi")
	}
	if v, ok := r.catchall["multiFormat"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for multiFormat: expected string, got %T", v)
		}
		r.MultiFormat = vt
		delete(r.catchall, "MultiFormat")
	}
	if v, ok := r.catchall["name"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for name: expected string, got %T", v)
		}
		r.Name = vt
		delete(r.catchall, "Name")
	}
	if v, ok := r.catchall["options"]; ok {
		vt, ok := v.([]*Option)
		if !ok {
			return fmt.Errorf("wrong type for options: expected []*Option, got %T", v)
		}
		r.Options = vt
		delete(r.catchall, "Options")
	}
	if v, ok := r.catchall["query"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for query: expected string, got %T", v)
		}
		r.Query = vt
		delete(r.catchall, "Query")
	}
	if v, ok := r.catchall["refresh"]; ok {
		vt, ok := v.(BoolInt)
		if !ok {
			return fmt.Errorf("wrong type for refresh: expected BoolInt, got %T", v)
		}
		r.Refresh = vt
		delete(r.catchall, "Refresh")
	}
	if v, ok := r.catchall["regex"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for regex: expected string, got %T", v)
		}
		r.Regex = vt
		delete(r.catchall, "Regex")
	}
	if v, ok := r.catchall["skipUrlSync"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for skipUrlSync: expected bool, got %T", v)
		}
		r.SkipUrlSync = vt
		delete(r.catchall, "SkipUrlSync")
	}
	if v, ok := r.catchall["sort"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for sort: expected int, got %T", v)
		}
		r.Sort = vt
		delete(r.catchall, "Sort")
	}
	if v, ok := r.catchall["tagValuesQuery"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for tagValuesQuery: expected string, got %T", v)
		}
		r.TagValuesQuery = vt
		delete(r.catchall, "TagValuesQuery")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	if v, ok := r.catchall["tagsQuery"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for tagsQuery: expected string, got %T", v)
		}
		r.TagsQuery = vt
		delete(r.catchall, "TagsQuery")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	if v, ok := r.catchall["useTags"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for useTags: expected bool, got %T", v)
		}
		r.UseTags = vt
		delete(r.catchall, "UseTags")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *SettingsType) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["interval"] = r.Interval
	out["min_doc_count"] = r.MinDocCount
	out["order"] = r.Order
	out["orderBy"] = r.OrderBy
	out["size"] = r.Size
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *SettingsType) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["interval"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for interval: expected string, got %T", v)
		}
		r.Interval = vt
		delete(r.catchall, "Interval")
	}
	if v, ok := r.catchall["min_doc_count"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for min_doc_count: expected int, got %T", v)
		}
		r.MinDocCount = vt
		delete(r.catchall, "MinDocCount")
	}
	if v, ok := r.catchall["order"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for order: expected string, got %T", v)
		}
		r.Order = vt
		delete(r.catchall, "Order")
	}
	if v, ok := r.catchall["orderBy"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for orderBy: expected string, got %T", v)
		}
		r.OrderBy = vt
		delete(r.catchall, "OrderBy")
	}
	if v, ok := r.catchall["size"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for size: expected string, got %T", v)
		}
		r.Size = vt
		delete(r.catchall, "Size")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertNotification) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["id"] = r.ID
	out["name"] = r.Name
	out["type"] = r.Type
	out["isDefault"] = r.IsDefault
	out["disableResolveMessage"] = r.DisableResolveMessage
	out["sendReminder"] = r.SendReminder
	out["frequency"] = r.Frequency
	out["settings"] = r.Settings
	out["uid"] = r.UID
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertNotification) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["id"]; ok {
		vt, ok := v.(int64)
		if !ok {
			return fmt.Errorf("wrong type for id: expected int64, got %T", v)
		}
		r.ID = vt
		delete(r.catchall, "ID")
	}
	if v, ok := r.catchall["name"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for name: expected string, got %T", v)
		}
		r.Name = vt
		delete(r.catchall, "Name")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	if v, ok := r.catchall["isDefault"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for isDefault: expected bool, got %T", v)
		}
		r.IsDefault = vt
		delete(r.catchall, "IsDefault")
	}
	if v, ok := r.catchall["disableResolveMessage"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for disableResolveMessage: expected bool, got %T", v)
		}
		r.DisableResolveMessage = vt
		delete(r.catchall, "DisableResolveMessage")
	}
	if v, ok := r.catchall["sendReminder"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for sendReminder: expected bool, got %T", v)
		}
		r.SendReminder = vt
		delete(r.catchall, "SendReminder")
	}
	if v, ok := r.catchall["frequency"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for frequency: expected string, got %T", v)
		}
		r.Frequency = vt
		delete(r.catchall, "Frequency")
	}
	if v, ok := r.catchall["settings"]; ok {
		vt, ok := v.(interface{})
		if !ok {
			return fmt.Errorf("wrong type for settings: expected interface{}, got %T", v)
		}
		r.Settings = vt
		delete(r.catchall, "Settings")
	}
	if v, ok := r.catchall["uid"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for uid: expected string, got %T", v)
		}
		r.UID = vt
		delete(r.catchall, "UID")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Link) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["asDropdown"] = r.AsDropdown
	out["dashUri"] = r.DashURI
	out["dashboard"] = r.Dashboard
	out["icon"] = r.Icon
	out["includeVars"] = r.IncludeVars
	out["keepTime"] = r.KeepTime
	out["params"] = r.Params
	out["tags"] = r.Tags
	out["targetBlank"] = r.TargetBlank
	out["title"] = r.Title
	out["tooltip"] = r.Tooltip
	out["type"] = r.Type
	out["url"] = r.URL
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Link) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["asDropdown"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for asDropdown: expected *bool, got %T", v)
		}
		r.AsDropdown = vt
		delete(r.catchall, "AsDropdown")
	}
	if v, ok := r.catchall["dashUri"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for dashUri: expected *string, got %T", v)
		}
		r.DashURI = vt
		delete(r.catchall, "DashURI")
	}
	if v, ok := r.catchall["dashboard"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for dashboard: expected *string, got %T", v)
		}
		r.Dashboard = vt
		delete(r.catchall, "Dashboard")
	}
	if v, ok := r.catchall["icon"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for icon: expected *string, got %T", v)
		}
		r.Icon = vt
		delete(r.catchall, "Icon")
	}
	if v, ok := r.catchall["includeVars"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for includeVars: expected bool, got %T", v)
		}
		r.IncludeVars = vt
		delete(r.catchall, "IncludeVars")
	}
	if v, ok := r.catchall["keepTime"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for keepTime: expected *bool, got %T", v)
		}
		r.KeepTime = vt
		delete(r.catchall, "KeepTime")
	}
	if v, ok := r.catchall["params"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for params: expected *string, got %T", v)
		}
		r.Params = vt
		delete(r.catchall, "Params")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	if v, ok := r.catchall["targetBlank"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for targetBlank: expected *bool, got %T", v)
		}
		r.TargetBlank = vt
		delete(r.catchall, "TargetBlank")
	}
	if v, ok := r.catchall["title"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for title: expected string, got %T", v)
		}
		r.Title = vt
		delete(r.catchall, "Title")
	}
	if v, ok := r.catchall["tooltip"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for tooltip: expected *string, got %T", v)
		}
		r.Tooltip = vt
		delete(r.catchall, "Tooltip")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	if v, ok := r.catchall["url"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for url: expected *string, got %T", v)
		}
		r.URL = vt
		delete(r.catchall, "URL")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *TextPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["content"] = r.Content
	out["mode"] = r.Mode
	out["pageSize"] = r.PageSize
	out["scroll"] = r.Scroll
	out["showHeader"] = r.ShowHeader
	out["sort"] = r.Sort
	out["styles"] = r.Styles
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *TextPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["content"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for content: expected string, got %T", v)
		}
		r.Content = vt
		delete(r.catchall, "Content")
	}
	if v, ok := r.catchall["mode"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for mode: expected string, got %T", v)
		}
		r.Mode = vt
		delete(r.catchall, "Mode")
	}
	if v, ok := r.catchall["pageSize"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for pageSize: expected uint, got %T", v)
		}
		r.PageSize = vt
		delete(r.catchall, "PageSize")
	}
	if v, ok := r.catchall["scroll"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for scroll: expected bool, got %T", v)
		}
		r.Scroll = vt
		delete(r.catchall, "Scroll")
	}
	if v, ok := r.catchall["showHeader"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for showHeader: expected bool, got %T", v)
		}
		r.ShowHeader = vt
		delete(r.catchall, "ShowHeader")
	}
	if v, ok := r.catchall["sort"]; ok {
		vt, ok := v.(*Sort)
		if !ok {
			return fmt.Errorf("wrong type for sort: expected *Sort, got %T", v)
		}
		r.Sort = vt
		delete(r.catchall, "Sort")
	}
	if v, ok := r.catchall["styles"]; ok {
		vt, ok := v.([]ColumnStyle)
		if !ok {
			return fmt.Errorf("wrong type for styles: expected []ColumnStyle, got %T", v)
		}
		r.Styles = vt
		delete(r.catchall, "Styles")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertCondition) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["evaluator"] = r.Evaluator
	out["operator"] = r.Operator
	out["query"] = r.Query
	out["reducer"] = r.Reducer
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertCondition) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["evaluator"]; ok {
		vt, ok := v.(AlertEvaluator)
		if !ok {
			return fmt.Errorf("wrong type for evaluator: expected AlertEvaluator, got %T", v)
		}
		r.Evaluator = vt
		delete(r.catchall, "Evaluator")
	}
	if v, ok := r.catchall["operator"]; ok {
		vt, ok := v.(AlertOperator)
		if !ok {
			return fmt.Errorf("wrong type for operator: expected AlertOperator, got %T", v)
		}
		r.Operator = vt
		delete(r.catchall, "Operator")
	}
	if v, ok := r.catchall["query"]; ok {
		vt, ok := v.(AlertQuery)
		if !ok {
			return fmt.Errorf("wrong type for query: expected AlertQuery, got %T", v)
		}
		r.Query = vt
		delete(r.catchall, "Query")
	}
	if v, ok := r.catchall["reducer"]; ok {
		vt, ok := v.(AlertReducer)
		if !ok {
			return fmt.Errorf("wrong type for reducer: expected AlertReducer, got %T", v)
		}
		r.Reducer = vt
		delete(r.catchall, "Reducer")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *ColumnStyle) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["alias"] = r.Alias
	out["colorMode"] = r.ColorMode
	out["colors"] = r.Colors
	out["dateFormat"] = r.DateFormat
	out["decimals"] = r.Decimals
	out["link"] = r.Link
	out["linkTargetBlank"] = r.LinkTargetBlank
	out["linkTooltip"] = r.LinkTooltip
	out["linkUrl"] = r.LinkURL
	out["pattern"] = r.Pattern
	out["thresholds"] = r.Thresholds
	out["type"] = r.Type
	out["unit"] = r.Unit
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *ColumnStyle) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["alias"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for alias: expected *string, got %T", v)
		}
		r.Alias = vt
		delete(r.catchall, "Alias")
	}
	if v, ok := r.catchall["colorMode"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for colorMode: expected *string, got %T", v)
		}
		r.ColorMode = vt
		delete(r.catchall, "ColorMode")
	}
	if v, ok := r.catchall["colors"]; ok {
		vt, ok := v.(*[]string)
		if !ok {
			return fmt.Errorf("wrong type for colors: expected *[]string, got %T", v)
		}
		r.Colors = vt
		delete(r.catchall, "Colors")
	}
	if v, ok := r.catchall["dateFormat"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for dateFormat: expected *string, got %T", v)
		}
		r.DateFormat = vt
		delete(r.catchall, "DateFormat")
	}
	if v, ok := r.catchall["decimals"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for decimals: expected *int, got %T", v)
		}
		r.Decimals = vt
		delete(r.catchall, "Decimals")
	}
	if v, ok := r.catchall["link"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for link: expected *bool, got %T", v)
		}
		r.Link = vt
		delete(r.catchall, "Link")
	}
	if v, ok := r.catchall["linkTargetBlank"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for linkTargetBlank: expected *bool, got %T", v)
		}
		r.LinkTargetBlank = vt
		delete(r.catchall, "LinkTargetBlank")
	}
	if v, ok := r.catchall["linkTooltip"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for linkTooltip: expected *string, got %T", v)
		}
		r.LinkTooltip = vt
		delete(r.catchall, "LinkTooltip")
	}
	if v, ok := r.catchall["linkUrl"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for linkUrl: expected *string, got %T", v)
		}
		r.LinkURL = vt
		delete(r.catchall, "LinkURL")
	}
	if v, ok := r.catchall["pattern"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for pattern: expected string, got %T", v)
		}
		r.Pattern = vt
		delete(r.catchall, "Pattern")
	}
	if v, ok := r.catchall["thresholds"]; ok {
		vt, ok := v.(*[]string)
		if !ok {
			return fmt.Errorf("wrong type for thresholds: expected *[]string, got %T", v)
		}
		r.Thresholds = vt
		delete(r.catchall, "Thresholds")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	if v, ok := r.catchall["unit"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for unit: expected *string, got %T", v)
		}
		r.Unit = vt
		delete(r.catchall, "Unit")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *SparkLine) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["fillColor"] = r.FillColor
	out["full"] = r.Full
	out["lineColor"] = r.LineColor
	out["show"] = r.Show
	out["ymin"] = r.YMin
	out["ymax"] = r.YMax
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *SparkLine) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["fillColor"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for fillColor: expected *string, got %T", v)
		}
		r.FillColor = vt
		delete(r.catchall, "FillColor")
	}
	if v, ok := r.catchall["full"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for full: expected bool, got %T", v)
		}
		r.Full = vt
		delete(r.catchall, "Full")
	}
	if v, ok := r.catchall["lineColor"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for lineColor: expected *string, got %T", v)
		}
		r.LineColor = vt
		delete(r.catchall, "LineColor")
	}
	if v, ok := r.catchall["show"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for show: expected bool, got %T", v)
		}
		r.Show = vt
		delete(r.catchall, "Show")
	}
	if v, ok := r.catchall["ymin"]; ok {
		vt, ok := v.(*float64)
		if !ok {
			return fmt.Errorf("wrong type for ymin: expected *float64, got %T", v)
		}
		r.YMin = vt
		delete(r.catchall, "YMin")
	}
	if v, ok := r.catchall["ymax"]; ok {
		vt, ok := v.(*float64)
		if !ok {
			return fmt.Errorf("wrong type for ymax: expected *float64, got %T", v)
		}
		r.YMax = vt
		delete(r.catchall, "YMax")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *RowPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["panels"] = r.Panels
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *RowPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["panels"]; ok {
		vt, ok := v.([]*Panel)
		if !ok {
			return fmt.Errorf("wrong type for panels: expected []*Panel, got %T", v)
		}
		r.Panels = vt
		delete(r.catchall, "Panels")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Sort) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["col"] = r.Col
	out["desc"] = r.Desc
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Sort) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["col"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for col: expected int, got %T", v)
		}
		r.Col = vt
		delete(r.catchall, "Col")
	}
	if v, ok := r.catchall["desc"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for desc: expected bool, got %T", v)
		}
		r.Desc = vt
		delete(r.catchall, "Desc")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Metric) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["id"] = r.ID
	out["field"] = r.Field
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Metric) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["id"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for id: expected string, got %T", v)
		}
		r.ID = vt
		delete(r.catchall, "ID")
	}
	if v, ok := r.catchall["field"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for field: expected string, got %T", v)
		}
		r.Field = vt
		delete(r.catchall, "Field")
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Timepicker) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["refresh_intervals"] = r.RefreshIntervals
	out["time_options"] = r.TimeOptions
	out["now"] = r.Now
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Timepicker) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["refresh_intervals"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for refresh_intervals: expected []string, got %T", v)
		}
		r.RefreshIntervals = vt
		delete(r.catchall, "RefreshIntervals")
	}
	if v, ok := r.catchall["time_options"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for time_options: expected []string, got %T", v)
		}
		r.TimeOptions = vt
		delete(r.catchall, "TimeOptions")
	}
	if v, ok := r.catchall["now"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for now: expected *bool, got %T", v)
		}
		r.Now = vt
		delete(r.catchall, "Now")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *PluginlistPanel) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["limit"] = r.Limit
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *PluginlistPanel) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["limit"]; ok {
		vt, ok := v.(int)
		if !ok {
			return fmt.Errorf("wrong type for limit: expected int, got %T", v)
		}
		r.Limit = vt
		delete(r.catchall, "Limit")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *StackdriverAlignOptions) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["expanded"] = r.Expanded
	out["label"] = r.Label
	out["options"] = r.Options
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *StackdriverAlignOptions) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["expanded"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for expanded: expected bool, got %T", v)
		}
		r.Expanded = vt
		delete(r.catchall, "Expanded")
	}
	if v, ok := r.catchall["label"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for label: expected string, got %T", v)
		}
		r.Label = vt
		delete(r.catchall, "Label")
	}
	if v, ok := r.catchall["options"]; ok {
		vt, ok := v.([]StackdriverAlignOption)
		if !ok {
			return fmt.Errorf("wrong type for options: expected []StackdriverAlignOption, got %T", v)
		}
		r.Options = vt
		delete(r.catchall, "Options")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *Board) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["id"] = r.ID
	out["uid"] = r.UID
	out["title"] = r.Title
	out["tags"] = r.Tags
	out["style"] = r.Style
	out["timezone"] = r.Timezone
	out["editable"] = r.Editable
	out["hideControls"] = r.HideControls
	out["graphTooltip"] = r.GraphTooltip
	out["panels"] = r.Panels
	out["time"] = r.Time
	out["timepicker"] = r.Timepicker
	out["templating"] = r.Templating
	out["annotations"] = r.Annotations
	out["refresh"] = r.Refresh
	out["schemaVersion"] = r.SchemaVersion
	out["version"] = r.Version
	out["links"] = r.Links
	out["description"] = r.Description
	out["slug"] = r.Slug
	out["originalTitle"] = r.OriginalTitle
	out["sharedCrosshair"] = r.SharedCrosshair
	out["rows"] = r.Rows
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *Board) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["id"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for id: expected uint, got %T", v)
		}
		r.ID = vt
		delete(r.catchall, "ID")
	}
	if v, ok := r.catchall["uid"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for uid: expected string, got %T", v)
		}
		r.UID = vt
		delete(r.catchall, "UID")
	}
	if v, ok := r.catchall["title"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for title: expected string, got %T", v)
		}
		r.Title = vt
		delete(r.catchall, "Title")
	}
	if v, ok := r.catchall["tags"]; ok {
		vt, ok := v.([]string)
		if !ok {
			return fmt.Errorf("wrong type for tags: expected []string, got %T", v)
		}
		r.Tags = vt
		delete(r.catchall, "Tags")
	}
	if v, ok := r.catchall["style"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for style: expected string, got %T", v)
		}
		r.Style = vt
		delete(r.catchall, "Style")
	}
	if v, ok := r.catchall["timezone"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for timezone: expected string, got %T", v)
		}
		r.Timezone = vt
		delete(r.catchall, "Timezone")
	}
	if v, ok := r.catchall["editable"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for editable: expected bool, got %T", v)
		}
		r.Editable = vt
		delete(r.catchall, "Editable")
	}
	if v, ok := r.catchall["hideControls"]; ok {
		vt, ok := v.(*bool)
		if !ok {
			return fmt.Errorf("wrong type for hideControls: expected *bool, got %T", v)
		}
		r.HideControls = vt
		delete(r.catchall, "HideControls")
	}
	if v, ok := r.catchall["graphTooltip"]; ok {
		vt, ok := v.(*int)
		if !ok {
			return fmt.Errorf("wrong type for graphTooltip: expected *int, got %T", v)
		}
		r.GraphTooltip = vt
		delete(r.catchall, "GraphTooltip")
	}
	if v, ok := r.catchall["panels"]; ok {
		vt, ok := v.([]*Panel)
		if !ok {
			return fmt.Errorf("wrong type for panels: expected []*Panel, got %T", v)
		}
		r.Panels = vt
		delete(r.catchall, "Panels")
	}
	if v, ok := r.catchall["time"]; ok {
		vt, ok := v.(Time)
		if !ok {
			return fmt.Errorf("wrong type for time: expected Time, got %T", v)
		}
		r.Time = vt
		delete(r.catchall, "Time")
	}
	if v, ok := r.catchall["timepicker"]; ok {
		vt, ok := v.(Timepicker)
		if !ok {
			return fmt.Errorf("wrong type for timepicker: expected Timepicker, got %T", v)
		}
		r.Timepicker = vt
		delete(r.catchall, "Timepicker")
	}
	if v, ok := r.catchall["templating"]; ok {
		vt, ok := v.(Templating)
		if !ok {
			return fmt.Errorf("wrong type for templating: expected Templating, got %T", v)
		}
		r.Templating = vt
		delete(r.catchall, "Templating")
	}
	if v, ok := r.catchall["annotations"]; ok {
		vt, ok := v.(AnnotationsType)
		if !ok {
			return fmt.Errorf("wrong type for annotations: expected AnnotationsType, got %T", v)
		}
		r.Annotations = vt
		delete(r.catchall, "Annotations")
	}
	if v, ok := r.catchall["refresh"]; ok {
		vt, ok := v.(*BoolString)
		if !ok {
			return fmt.Errorf("wrong type for refresh: expected *BoolString, got %T", v)
		}
		r.Refresh = vt
		delete(r.catchall, "Refresh")
	}
	if v, ok := r.catchall["schemaVersion"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for schemaVersion: expected uint, got %T", v)
		}
		r.SchemaVersion = vt
		delete(r.catchall, "SchemaVersion")
	}
	if v, ok := r.catchall["version"]; ok {
		vt, ok := v.(uint)
		if !ok {
			return fmt.Errorf("wrong type for version: expected uint, got %T", v)
		}
		r.Version = vt
		delete(r.catchall, "Version")
	}
	if v, ok := r.catchall["links"]; ok {
		vt, ok := v.([]*Link)
		if !ok {
			return fmt.Errorf("wrong type for links: expected []*Link, got %T", v)
		}
		r.Links = vt
		delete(r.catchall, "Links")
	}
	if v, ok := r.catchall["description"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for description: expected *string, got %T", v)
		}
		r.Description = vt
		delete(r.catchall, "Description")
	}
	if v, ok := r.catchall["slug"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for slug: expected *string, got %T", v)
		}
		r.Slug = vt
		delete(r.catchall, "Slug")
	}
	if v, ok := r.catchall["originalTitle"]; ok {
		vt, ok := v.(*string)
		if !ok {
			return fmt.Errorf("wrong type for originalTitle: expected *string, got %T", v)
		}
		r.OriginalTitle = vt
		delete(r.catchall, "OriginalTitle")
	}
	if v, ok := r.catchall["sharedCrosshair"]; ok {
		vt, ok := v.(bool)
		if !ok {
			return fmt.Errorf("wrong type for sharedCrosshair: expected bool, got %T", v)
		}
		r.SharedCrosshair = vt
		delete(r.catchall, "SharedCrosshair")
	}
	if v, ok := r.catchall["rows"]; ok {
		vt, ok := v.([]*Row)
		if !ok {
			return fmt.Errorf("wrong type for rows: expected []*Row, got %T", v)
		}
		r.Rows = vt
		delete(r.catchall, "Rows")
	}
	return nil
}

// MarshalJSON implements json.Marshaler.
func (r *AlertOperator) MarshalJSON() ([]byte, error) {
	out := map[string]interface{}{}
	for k, v := range r.catchall {
		out[k] = v
	}
	out["type"] = r.Type
	return json.Marshal(out)
}

// UnmarshalJSON implements json.Unmarshaler.
func (r *AlertOperator) UnmarshalJSON(data []byte) error {
	r.catchall = make(map[string]interface{})
	err := json.Unmarshal(data, &r.catchall)
	if err != nil {
		return err
	}
	if v, ok := r.catchall["type"]; ok {
		vt, ok := v.(string)
		if !ok {
			return fmt.Errorf("wrong type for type: expected string, got %T", v)
		}
		r.Type = vt
		delete(r.catchall, "Type")
	}
	return nil
}
